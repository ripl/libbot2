include_guard(GLOBAL)

# Macros for automatically compiling LCM types into C, Java, and Python
# libraries.
#
# The primary macro is:
#     lcmtypes_build([C_AGGREGATE_HEADER header_fname]
#                    [C_LIBNAME lib_name]
#                    [JAVA_DEST_DIR dir_name]
#                    [PY_DEST_DIR dir_name]
#                    )
#
# It expects that the directory ${PROJECT_SOURCE_DIR}/lcmtypes contains all
# the LCM types used by the system.  The macro generates C, Java, and Python
# bindings.  See the C, Java, and Python sections below for information on
# language specific options and generated results.
#
# After invoking this macro, the following variables will be set:
#
#   LCMTYPES_LIBS
#   LCMTYPES_JAR
#
#
# C
# ==
#
# C bindings will be placed in ${PROJECT_SOURCE_DIR}/lcmtypes/c.
#
# The autogenerated C bindings also get compiled to a static and shared
# library.  The library prefix will be stored in LCMTYPES_LIBS on output.
# This prefix can be manually set using the C_LIBNAME option.
#
# Additionally, a header file will be generated that automatically includes
# all of the other automatically generated header files.  The name of this
# header file defaults to a cleaned-up version of "${PROJECT_NAME}.h"
# (non-alphanumeric characters replaced with underscores), but can
# be manually set using the C_AGGREGATE_HEADER option.
#
# C++
# ==
#
# C++ bindings will be placed in ${PROJECT_SOURCE_DIR}/lcmtypes/cpp.
#
# The autogenerated CPP bindings are header only, so no library is created.
#
# A header file will be generated that automatically includes
# all of the other automatically generated header files.  The name of this
# header file defaults to a cleaned-up version of "${PROJECT_NAME}.hpp"
# (non-alphanumeric characters replaced with underscores), but can
# be manually set using the CPP_AGGREGATE_HEADER option.
#
#
# Java
# ====
#
# If Java is available, then Java bindings are be generated and placed in
#    ${PROJECT_SOURCE_DIR}/lcmtypes/java
#
# This directory can be changed using the JAVA_DEST_DIR option.
#
# Additionally, targets are added to automatically compile the .java files to a
# .jar file. The location of this jar file is stored in LCMTYPES_JAR
#
# and the .jar file will be installed to
#   ${CMAKE_INSTALL_DATADIR}/java
#
#
# Python
# ======
#
# If Python is enabled, then python bindings will be generated and placed in
#    ${PROJECT_SOURCE_DIR}/lcmtypes/python
#
# This directory can be changed by setting the PY_DEST_DIR option.
#
# Additionally, the .py files will be installed to
#   ${CMAKE_INSTALL_PREFIX}/lib/python{X.Y}/dist-packages
#
# where {X.Y} refers to the python version used to build the .py files.
#
# ----
# File: lcmtypes.cmake
# Distributed with pods version: 12.09.21

macro(lcmtypes_get_types msgvar)
    # get a list of all LCM types
    file(GLOB __tmplcmtypes "${PROJECT_SOURCE_DIR}/lcmtypes/*.lcm")
    set(${msgvar} "")
    foreach(_msg ${__tmplcmtypes})
        # Try to filter out temporary and backup files
        if(${_msg} MATCHES "^[^\\.].*\\.lcm$")
            list(APPEND ${msgvar} ${_msg})
        endif(${_msg} MATCHES "^[^\\.].*\\.lcm$")
    endforeach(_msg)
endmacro()

function(lcmgen)
    execute_process(COMMAND ${LCM_GEN_EXECUTABLE} ${ARGV} RESULT_VARIABLE lcmgen_result)
    if(NOT lcmgen_result EQUAL 0)
        message(FATAL_ERROR "lcm-gen failed")
    endif()
endfunction()

function(lcmtypes_add_clean_dir clean_dir)
    get_directory_property(acfiles ADDITIONAL_MAKE_CLEAN_FILES)
    list(APPEND acfiles ${clean_dir})
    set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${acfiles}")
endfunction()

function(lcmtypes_build_c)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    string(REGEX REPLACE "[^a-zA-Z0-9]" "_" __sanitized_project_name "${PROJECT_NAME}")

    # set some defaults

    # library name
    set(libname "lcmtypes_${PROJECT_NAME}")

    # header file that includes all other generated header files
    set(agg_h_bname "${__sanitized_project_name}.h")

    # allow defaults to be overriden by function parameters
    set(modewords C_LIBNAME C_AGGREGATE_HEADER EXPORT)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL C_AGGREGATE_HEADER)
            set(agg_h_bname "${word}")
            set(curmode "")
        elseif(curmode STREQUAL C_LIBNAME)
            set(libname "${word}")
            set(curmode "")
        elseif(curmode STREQUAL EXPORT)
            set(_export_name "${word}")
            set(curmode "")
        endif()
    endforeach()

    # generate C bindings for LCM types
    set(_lcmtypes_c_dir ${PROJECT_SOURCE_DIR}/lcmtypes/c/lcmtypes)

    # blow away any existing auto-generated files.
    file(REMOVE_RECURSE ${_lcmtypes_c_dir})

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_c_dir})
    lcmgen(--lazy -c --c-cpath ${_lcmtypes_c_dir} --c-hpath ${_lcmtypes_c_dir} --cinclude lcmtypes ${_lcmtypes})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_c ALL
        COMMAND sh -c '[ -d ${_lcmtypes_c_dir} ] || mkdir -p ${_lcmtypes_c_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy -c ${_lcmtypes} --c-cpath ${_lcmtypes_c_dir} --c-hpath ${_lcmtypes_c_dir}')

    # get a list of all generated .c files
    file(GLOB _lcmtypes_c_files ${_lcmtypes_c_dir}/*.c)

    # aggregate into a static library
    add_library(${libname} STATIC ${_lcmtypes_c_files})
    set_target_properties(${libname} PROPERTIES
      C_CLANG_TIDY ""
      C_CPPLINT ""
      C_INCLUDE_WHAT_YOU_USE ""
    )
    set_target_properties(${libname} PROPERTIES POSITION_INDEPENDENT_CODE ON)
    target_link_libraries(${libname} ${LCM_NAMESPACE}lcm-coretypes ${LCM_NAMESPACE}lcm)
    target_include_directories(${libname} PUBLIC
        $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/lcmtypes>
        $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/lcmtypes>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}> )
    add_dependencies(${libname} lcmgen_c)

    #    add_library("${libname}-static" STATIC ${_lcmtypes_c_files})
    #    set_source_files_properties(${_lcmtypes_c_files} PROPERTIES COMPILE_FLAGS "-I${PROJECT_SOURCE_DIR}/lcmtypes/c")
    #    set_target_properties("${libname}-static" PROPERTIES OUTPUT_NAME "${libname}")
    #    set_target_properties("${libname}-static" PROPERTIES PREFIX "lib")
    #    set_target_properties("${libname}-static" PROPERTIES CLEAN_DIRECT_OUTPUT 1)
    #    add_dependencies("${libname}-static" lcmgen_c)

    # XXX don't build a shared library, as it makes using 3rd-party/external
    # LCM types awkward (linker will try to link external symbols at library link time,
    # rather than executable link time)

    #    # aggregate into a shared library
    #    add_library(${libname} SHARED ${_lcmtypes_c_files})
    #    set_target_properties("${libname}" PROPERTIES CLEAN_DIRECT_OUTPUT 1)
    #    add_dependencies("${libname}" lcmgen_c)
    #    target_link_libraries(${libname} ${LCM_LDFLAGS})

    # create a header file aggregating all of the autogenerated .h files
    set(__agg_h_fname "${_lcmtypes_c_dir}/${agg_h_bname}")
    file(WRITE ${__agg_h_fname}
        "#ifndef __lcmtypes_${__sanitized_project_name}_h__\n"
        "#define __lcmtypes_${__sanitized_project_name}_h__\n\n/* IWYU pragma: begin_exports */\n")

    # get a list of all generated .h files
    file(GLOB _lcmtypes_h_files ${_lcmtypes_c_dir}/*.h)
    foreach(h_file ${_lcmtypes_h_files})
        file(RELATIVE_PATH __tmp_path ${_lcmtypes_c_dir} ${h_file})
        if(NOT __tmp_path STREQUAL agg_h_bname)
            file(APPEND ${__agg_h_fname} "#include \"${__tmp_path}\"\n")
        endif()
    endforeach()
    file(APPEND ${__agg_h_fname} "/* IWYU pragma: end_exports */\n\n#endif\n")
    list(APPEND _lcmtypes_h_files ${__agg_h_fname})
    unset(__sanitized_project_name)
    unset(__agg_h_fname)

    # make header files and libraries public
    install(TARGETS ${libname}
      EXPORT ${_export_name}
      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
    )
    pods_install_headers(${_lcmtypes_h_files} DESTINATION lcmtypes)

    # set some compilation variables
    set(LCMTYPES_LIBS ${libname} PARENT_SCOPE)

    # create a pkg-config file
  	pods_install_pkg_config_file(${libname}
    	CFLAGS
    	DESCRIPTION "LCM types for ${PROJECT_NAME}"
        LIBS -l${libname}
    	REQUIRES lcm
    	VERSION 0.0.0)

    lcmtypes_add_clean_dir("${PROJECT_SOURCE_DIR}/lcmtypes/c")
endfunction()

function(lcmtypes_build_cpp)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    string(REGEX REPLACE "[^a-zA-Z0-9]" "_" __sanitized_project_name "${PROJECT_NAME}")

    # set some defaults

    # header file that includes all other generated header files
    set(agg_hpp_bname "${__sanitized_project_name}.hpp")

    # allow defaults to be overriden by function parameters
    set(modewords CPP_AGGREGATE_HEADER)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL CPP_AGGREGATE_HEADER)
            set(agg_hpp_bname "${word}")
            set(curmode "")
        endif()
    endforeach()

    # generate CPP bindings for LCM types
    set(_lcmtypes_cpp_dir ${PROJECT_SOURCE_DIR}/lcmtypes/cpp/lcmtypes)

    # blow away any existing auto-generated files.
    file(REMOVE_RECURSE ${_lcmtypes_cpp_dir})

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_cpp_dir})
    lcmgen(--lazy --cpp --cpp-hpath ${_lcmtypes_cpp_dir} --cpp-include lcmtypes ${_lcmtypes})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_cpp ALL
        COMMAND sh -c '[ -d ${_lcmtypes_cpp_dir} ] || mkdir -p ${_lcmtypes_cpp_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy --cpp ${_lcmtypes} --cpp-hpath ${_lcmtypes_cpp_dir}')

    # get a list of all generated .hpp files
    file(GLOB_RECURSE _lcmtypes_hpp_files  ${_lcmtypes_cpp_dir}/*.hpp)

    # create a header file aggregating all of the autogenerated .hpp files
    set(__agg_hpp_fname "${_lcmtypes_cpp_dir}/${agg_hpp_bname}")
    file(WRITE ${__agg_hpp_fname}
        "#ifndef __lcmtypes_${__sanitized_project_name}_hpp__\n"
        "#define __lcmtypes_${__sanitized_project_name}_hpp__\n\n// IWYU pragma: begin_exports\n")
    foreach(hpp_file ${_lcmtypes_hpp_files})
        file(RELATIVE_PATH __tmp_path ${_lcmtypes_cpp_dir} ${hpp_file})
        file(APPEND ${__agg_hpp_fname} "#include \"${__tmp_path}\"\n")
        get_filename_component(__tmp_dir ${__tmp_path} PATH)
        pods_install_headers(${hpp_file} DESTINATION lcmtypes/${__tmp_dir})
    endforeach()
    file(APPEND ${__agg_hpp_fname} "// IWYU pragma: end_exports\n\n#endif\n")
    pods_install_headers(${__agg_hpp_fname} DESTINATION lcmtypes)
    unset(__sanitized_project_name)
    unset(__agg_hpp_fname)

    lcmtypes_add_clean_dir("${PROJECT_SOURCE_DIR}/lcmtypes/cpp")
endfunction()

function(lcmtypes_build_java)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    # do we have Java?
    if(NOT JAVA_FOUND)
        message(STATUS "Not building Java LCM type bindings (Can't find Java)")
        return()
    endif()

    # generate Java bindings for LCM types
    set(_lcmtypes_java_dir ${PROJECT_SOURCE_DIR}/lcmtypes/java)
    set(auto_manage_files YES)

    set(modewords JAVA_DEST_DIR)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL JAVA_DEST_DIR)
            set(_lcmtypes_java_dir "${word}")
            set(auto_manage_files NO)
            set(curmode "")
        endif()
    endforeach()

    # blow away any existing auto-generated files?
    if(auto_manage_files)
        file(REMOVE_RECURSE ${_lcmtypes_java_dir})
    endif()

    # run lcm-gen now
    execute_process(COMMAND mkdir -p ${_lcmtypes_java_dir})
    lcmgen(--lazy -j ${_lcmtypes} --jpath ${_lcmtypes_java_dir})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_java ALL
        COMMAND sh -c '[ -d ${_lcmtypes_java_dir} ] || mkdir -p ${_lcmtypes_java_dir}'
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy -j ${_lcmtypes} --jpath ${_lcmtypes_java_dir}')

    if(NOT auto_manage_files)
        return()
    endif()

    # get a list of all generated .java files
    file(GLOB_RECURSE _lcmtypes_java_files ${_lcmtypes_java_dir}/*.java)

    set(_output_name lcmtypes_${PROJECT_NAME})

    add_jar(lcmtypes_${PROJECT_NAME}-java
      SOURCES ${_lcmtypes_java_files}
      INCLUDE_JARS lcm-java
      OUTPUT_NAME ${_output_name}
    )
    add_dependencies(lcmtypes_${PROJECT_NAME}-java lcmgen_java)

    install_jar(lcmtypes_${PROJECT_NAME}-java
      DESTINATION ${CMAKE_INSTALL_DATADIR}/java
    )

    set(LCMTYPES_JAR "${CMAKE_CURRENT_BINARY_DIR}/${_output_name}.jar" PARENT_SCOPE)

    lcmtypes_add_clean_dir(${_lcmtypes_java_dir})
endfunction()

function(lcmtypes_build_python)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    find_package(PythonInterp 3.6 MODULE)
    if(NOT PYTHONINTERP_FOUND)
        message(STATUS "Not building Python LCM type bindings (Can't find Python)")
        return()
    endif()

    set(_lcmtypes_python_dir ${PROJECT_SOURCE_DIR}/lcmtypes/python)
    set(auto_manage_files YES)

    set(modewords PY_DEST_DIR)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL PY_DEST_DIR)
            set(_lcmtypes_python_dir "${word}")
            set(auto_manage_files NO)
            set(curmode "")
        endif()
    endforeach()

    # purge existing files?
    if(auto_manage_files)
        file(REMOVE_RECURSE ${_lcmtypes_python_dir})
    endif()

    # generate Python bindings for LCM types
    execute_process(COMMAND mkdir -p ${_lcmtypes_python_dir})
    execute_process(COMMAND ${LCM_GEN_EXECUTABLE} --lazy -p ${_lcmtypes} --ppath ${_lcmtypes_python_dir})

    # run lcm-gen at compile time
    add_custom_target(lcmgen_python ALL
        COMMAND sh -c '${LCM_GEN_EXECUTABLE} --lazy -p ${_lcmtypes} --ppath ${_lcmtypes_python_dir}')

    if(NOT auto_manage_files)
        return()
    endif()

    pods_install_python_packages(${_lcmtypes_python_dir})

    lcmtypes_add_clean_dir(${_lcmtypes_python_dir})
endfunction()

function(lcmtypes_install_types)
    lcmtypes_get_types(_lcmtypes)
    list(LENGTH _lcmtypes _num_lcmtypes)
    if(_num_lcmtypes EQUAL 0)
        return()
    endif()

    install(FILES ${_lcmtypes} DESTINATION ${CMAKE_INSTALL_DATADIR}/lcmtypes)
endfunction()

macro(lcmtypes_build)
    find_package(lcm 1.4 CONFIG REQUIRED)
    if(TARGET ${LCM_NAMESPACE}lcm-gen)
      get_target_property(LCM_GEN_EXECUTABLE ${LCM_NAMESPACE}lcm-gen IMPORTED_LOCATION)
      if(NOT LCM_GEN_EXECUTABLE)
        get_target_property(LCM_IMPORTED_CONFIGURATIONS ${LCM_NAMESPACE}lcm-gen IMPORTED_CONFIGURATIONS)
        if(LCM_IMPORTED_CONFIGURATIONS)
          list(GET LCM_IMPORTED_CONFIGURATIONS 0 lcm_CONFIGURATIONS)
          if(lcm_CONFIGURATIONS)
            get_target_property(LCM_GEN_EXECUTABLE ${LCM_NAMESPACE}lcm-gen IMPORTED_LOCATION_${lcm_CONFIGURATIONS})
          endif()
        endif()
      endif()
      if(NOT LCM_GEN_EXECUTABLE)
        message(FATAL_ERROR "lcm-gen path was not found.")
      endif()
    else()
      message(FATAL_ERROR "lcm-gen not found")
    endif()
    if(TARGET ${LCM_NAMESPACE}lcm-java)
      # Note: target property 'IMPORTED_LOCATION' is only available if LCM was
      # configured with CMake >= 3.9
      get_target_property(LCM_JAR_FILE ${LCM_NAMESPACE}lcm-java JAR_FILE)
    else()
      message(STATUS "Not building Java LCM type bindings (Can't find lcm-java)")
      set(skip_java_bindings ON)
    endif()

    lcmtypes_build_c(${ARGV})
    lcmtypes_build_cpp(${ARGV})
    if(NOT skip_java_bindings)
      lcmtypes_build_java(${ARGV})
    endif()
    lcmtypes_build_python(${ARGV})
    lcmtypes_install_types(${ARGV})
endmacro()
